ASSIGNMENT PDF IN SHORT FORM :


You will be tweaking the Xv6operating system as a part of this assignment.Task 1Waitx Sys CallAs a part of this task, you're expected to extend the current proc structure and addnew fields ctime, etime and rtime for creation time, end-time and total timerespectively of a process. When a new process gets created the kernel code shouldupdate the process creation time. The run-time should get updated after every clocktick for the process. To extract this information from the kernel add a new system callwhich extends wait. The new call will be:int waitx(int* wtime, int* rtime)The two arguments are pointers to integers to which waitx will assign the totalnumber of clock ticks during which process was waiting and total number of clockticks when the process was running. The return values for waitx should be same asthat of wait system-call. Create a test program which utilizes the waitx system call bycreating a ‘time’ like command for the same.Note: This can be used to implement your scheduler functions.Getpinfo Sys CallYou'll need to create a new system call for this part: ​int getpinfo(struct proc_stat*)​. This routine returns some basic information about each process: its process ID,total run time, how many times it has been chosen to run, which queue it is currentlyon 0, 1, 2, 3 or 4 (check Task 2 part c) and ticks received in each queue. To do this,you will need to create the ​proc_stat​ struct :-struct proc_stat {    int pid;   // PID of each process    float runtime;  // Use suitable unit of time    int num_run; // number of time the process is executed    int current_queue; // current assigned queue    int ticks[5]; // number of ticks each process has received at each of the 5  priorityqueue};
Task 2The default scheduler of xv6 is a round-robin based scheduler. In this task, you’llimplement 3 other scheduling policies and incorporate them in Xv6.(a) First come - First Served (FCFS)Implement a non preemptive ​policy that selects the process with the lowest creationtime. The process runs until it no longer needs CPU time.(b) Priority Based SchedulerA priority-based scheduler selects the process with the highest priority for execution.In case two or more processes have the same priority, we choose them in around-robin fashion. The priority of a process can be in the range [0,100], the smallervalue will represent higher priority. Set the default priority of a process as 60. Tochange the default priority add a new system call ​set_priority​ which can change thepriority of a process.int set_priority(int)The system-call returns the old-priority value of the process. In case the priority ofthe process increases (the value is lower than before), then rescheduling should bedone.(c) Multi-level Feedback queue schedulingMLFQ scheduler allows processes to move between different priority queues basedon their behavior and CPU bursts. If a process uses too much CPU time, it is pushedto a lower priority queue, leaving I/O bound and interactive processes for higherpriority queues. Also, to prevent starvation, it implements aging.Keeping all these benefits in mind, implement a simplified multi-level feedbackqueue scheduler.Scheduler Details :-1.Create five priority queues, with the highest priority being number as 0 andbottom queue with the lowest priority as 4.2.Assign a suitable value for 1 tick of CPU timer.



Commit at 6'54 am : Assignment 5 starts





